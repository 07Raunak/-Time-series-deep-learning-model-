# -*- coding: utf-8 -*-
"""10 years Motihari Minimum temperature analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1htGm8VM3en7DrwiAO-bOWW-yNIpC2Uth

#DATA

## Data preprocessing
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

df= pd.read_csv("/content/Temperature data of Motihari_10 Years.csv")
df.head

df.describe()

# df = pd.DataFrame(df)

df['date'] = pd.to_datetime(df[['year', 'month', 'day']])

df.head()

df=df.drop(['year','month','day','PRECTOTCORR','T2M_MAX'],axis=1)
df.head()

df = df.set_index('date')

df.head()

"""#LSTM"""

pip install tensorflow

#Importing some Libraries.
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler

# Load your dataset or generate one
# For this example, we'll create a sample dataset
# Replace this with your actual dataset loading code
# def generate_sample_data():
#     data = np.array([i for i in range(100)])
#     return data

# data = generate_sample_data().reshape(-1, 1)

data=df

# Normalize the data (scaling it between 0 and 1)
scaler = MinMaxScaler()
data_scaled = scaler.fit_transform(data)

# Split the data into sequences
sequence_length = 10
sequences = []
target = []

for i in range(len(data_scaled) - sequence_length):
    sequences.append(data_scaled[i:i+sequence_length])
    target.append(data_scaled[i+sequence_length])

X = np.array(sequences)
y = np.array(target)

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Build the LSTM model
model = Sequential()
model.add(LSTM(50, input_shape=(sequence_length, 1)))
model.add(Dense(1))

model.compile(optimizer='adam', loss='mean_squared_error')

# Train the model
model.fit(X_train, y_train, epochs=15, batch_size=16)

# Make predictions
y_pred = model.predict(X_test)

# Inverse transform to get predictions in original scale
y_pred_original = scaler.inverse_transform(y_pred)
y_test_original = scaler.inverse_transform(y_test)

# Print or visualize the results as needed
# print(y_test_original)
# print(y_pred_original)

"""## RMSE"""

from sklearn.metrics import mean_squared_error
# Calculate Mean Squared Error (MSE)
mse = mean_squared_error(y_test_original, y_pred_original)

# Calculate Root Mean Squared Error (RMSE)
rmse = np.sqrt(mse)

print(f'RMSE: {rmse:.2f}')

"""## MAPE"""

# Calculate Mean Absolute Percentage Error (MAPE)
def calculate_mape(actual, predicted):
    actual, predicted = np.array(actual), np.array(predicted)
    return np.mean(np.abs((actual - predicted) / actual)) * 100

# Assuming y_test contains the actual values and y_pred contains the predicted values
mape = calculate_mape(y_test_original, y_pred_original)
print(f'Mean Absolute Percentage Error (MAPE): {mape:.2f}%')

"""## MAE"""

# Calculating Mean Absolute Error (MAE))
from sklearn.metrics import mean_absolute_error

# Assuming y_test contains the actual values and y_pred contains the predicted values
mae = mean_absolute_error(y_test_original, y_pred_original)
print(f'Mean Absolute Error (MAE): {mae:.2f}')

"""## MSE"""

# Calculate Mean Squared Error (MSE)
from sklearn.metrics import mean_squared_error

# Assuming y_test contains the actual values and y_pred contains the predicted values
mse = mean_squared_error(y_test_original, y_pred_original)
print(f'Mean Squared Error (MSE): {mse:.2f}')

"""## R-Square"""

# Calculating R-Square
from sklearn.metrics import r2_score

# Assuming y_test contains the actual values and y_pred contains the predicted values
r_squared = r2_score(y_test_original, y_pred_original)
print(f'R-squared (R²): {r_squared:.2f}')

# Create a line plot
plt.plot(data)

# Add labels and a title
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.title('Simple Line Plot')

# Display the plot
plt.show()

"""## Line plot"""

# Assuming y_test contains the actual values and y_pred contains the predicted values
plt.figure(figsize=(12, 6))
plt.plot(y_test_original, label='Actual', marker='o')
plt.plot(y_pred_original, label='Predicted', marker='x')
plt.legend()
plt.title('Actual vs. Predicted Values')
plt.xlabel('Data Point')
plt.ylabel('Value')
plt.grid(True)
plt.show()

"""## Scatter plot"""

# Assuming y_test contains the actual values and y_pred contains the predicted values
plt.figure(figsize=(8, 8))
plt.scatter(y_test_original,y_pred_original, s=30, c='blue', alpha=0.5)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'k--', lw=2)
plt.title('Scatter Plot of Actual vs. Predicted Values')
plt.xlabel('Actual Values')
plt.ylabel('Predicted Values')
plt.grid(True)
plt.show()

"""# BI-LSTM

"""

import tensorflow as tf
from tensorflow import keras
from sklearn.metrics import mean_squared_error

#Loading our dataset.
data=df
data.head

# Load your temperature dataset
temperature_data = data['T2M_MIN'].values

# Data preprocessing
scaler = MinMaxScaler(feature_range=(0, 1))
temperature_data = scaler.fit_transform(temperature_data.reshape(-1, 1))

# Define the sequence length and split the data into sequences
sequence_length = 10  # You can adjust this to your specific needs
sequences = []
next_values = []

for i in range(len(temperature_data) - sequence_length):
    sequences.append(temperature_data[i:i+sequence_length])
    next_values.append(temperature_data[i+sequence_length])

X = np.array(sequences)
y = np.array(next_values)

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

# Build a Bi-LSTM model
model = keras.Sequential()
model.add(keras.layers.Bidirectional(keras.layers.LSTM(50, activation='relu'), input_shape=(sequence_length, 1)))
model.add(keras.layers.Dense(1))
model.compile(optimizer='adam', loss='mean_squared_error')

# Train the model
model.fit(X_train, y_train, epochs=15, batch_size=32)

# Make predictions
y_pred = model.predict(X_test)

# Inverse transform the predictions and actual values
y_pred = scaler.inverse_transform(y_pred)
y_test = scaler.inverse_transform(y_test)


# Plot the actual vs. predicted values
plt.figure(figsize=(12, 6))
plt.plot(y_test, label='Actual')
plt.plot(y_pred, label='Predicted')
plt.legend()
plt.show()





"""## RMSE , MAPE , MAE , MSE , R-Square"""

# Calculate the root mean squared error (RMSE)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))
print(f'Root Mean Squared Error: {rmse}')


# Printing RMSE's value
#print(f'Root Mean Squared Error: {rmse}')

# Calculate Mean Absolute Percentage Error (MAPE)
def calculate_mape(actual, predicted):
    actual, predicted = np.array(actual), np.array(predicted)
    return np.mean(np.abs((actual - predicted) / actual)) * 100

# Assuming y_test contains the actual values and y_pred contains the predicted values
mape = calculate_mape(y_test, y_pred)
print(f'Mean Absolute Percentage Error (MAPE): {mape:.2f}%')

# Calculating Mean Absolute Error (MAE))
from sklearn.metrics import mean_absolute_error

# Assuming y_test contains the actual values and y_pred contains the predicted values
mae = mean_absolute_error(y_test, y_pred)
print(f'Mean Absolute Error (MAE): {mae:.2f}')

# Calculate Mean Squared Error (MSE)
# Assuming y_test contains the actual values and y_pred contains the predicted values
mse = mean_squared_error(y_test, y_pred)
print(f'Mean Squared Error (MSE): {mse:.2f}')

# Calculate R-Square
from sklearn.metrics import r2_score

# Assuming y_test contains the actual values and y_pred contains the predicted values
r_squared = r2_score(y_test, y_pred)
print(f'R-squared (R²): {r_squared:.2f}')

"""##Line Plot"""

# Assuming y_test contains the actual values and y_pred contains the predicted values
plt.figure(figsize=(12, 6))
plt.plot(y_test, label='Actual', marker='o')
plt.plot(y_pred, label='Predicted', marker='x')
plt.legend()
plt.title('Actual vs. Predicted Values')
plt.xlabel('Data Point')
plt.ylabel('Value')
plt.grid(True)
plt.show()

"""## Scatter Plot"""

# Assuming y_test contains the actual values and y_pred contains the predicted values
plt.figure(figsize=(8, 8))
plt.scatter(y_test, y_pred, s=30, c='blue', alpha=0.5)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'k--', lw=2)
plt.title('Scatter Plot of Actual vs. Predicted Values')
plt.xlabel('Actual Values')
plt.ylabel('Predicted Values')
plt.grid(True)
plt.show()

"""#GRU"""

#Libraries are already imported above.

#Loading our dataset.
data=df
data.head

# Load your temperature dataset
temperature_data = data['T2M_MIN'].values

# Data preprocessing
scaler = MinMaxScaler(feature_range=(0, 1))
temperature_data = scaler.fit_transform(temperature_data.reshape(-1, 1))

# Define the sequence length and split the data into sequences
sequence_length = 10  # You can adjust this to your specific needs
sequences = []
next_values = []

for i in range(len(temperature_data) - sequence_length):
    sequences.append(temperature_data[i:i+sequence_length])
    next_values.append(temperature_data[i+sequence_length])

X = np.array(sequences)
y = np.array(next_values)

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

# Build a GRU model
model = keras.Sequential()
model.add(keras.layers.GRU(50, activation='relu', input_shape=(sequence_length, 1)))
model.add(keras.layers.Dense(1))
model.compile(optimizer='adam', loss='mean_squared_error')

# Train the model
model.fit(X_train, y_train, epochs=15, batch_size=32)

# Make predictions
y_pred = model.predict(X_test)

# Inverse transform the predictions and actual values
y_pred = scaler.inverse_transform(y_pred)
y_test = scaler.inverse_transform(y_test)


# Plot the actual vs. predicted values
plt.figure(figsize=(12, 6))
plt.plot(y_test, label='Actual')
plt.plot(y_pred, label='Predicted')
plt.legend()
plt.show()

"""## RMSE , MAPE , MAE , MSE , R-Square"""

# Calculate the root mean squared error (RMSE)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))
print(f'Root Mean Squared Error: {rmse}')

# Printing RMSE's value
#print(f'Root Mean Squared Error: {rmse}')

# Calculate Mean Absolute Percentage Error (MAPE)
def calculate_mape(actual, predicted):
    actual, predicted = np.array(actual), np.array(predicted)
    return np.mean(np.abs((actual - predicted) / actual)) * 100

# Assuming y_test contains the actual values and y_pred contains the predicted values
mape = calculate_mape(y_test, y_pred)
print(f'Mean Absolute Percentage Error (MAPE): {mape:.2f}%')

# Calculating Mean Absolute Error (MAE))
from sklearn.metrics import mean_absolute_error

# Assuming y_test contains the actual values and y_pred contains the predicted values
mae = mean_absolute_error(y_test, y_pred)
print(f'Mean Absolute Error (MAE): {mae:.2f}')

# Calculate Mean Squared Error (MSE)
# Assuming y_test contains the actual values and y_pred contains the predicted values
mse = mean_squared_error(y_test, y_pred)
print(f'Mean Squared Error (MSE): {mse:.2f}')

# Calculate R-Square
from sklearn.metrics import r2_score

# Assuming y_test contains the actual values and y_pred contains the predicted values
r_squared = r2_score(y_test, y_pred)
print(f'R-squared (R²): {r_squared:.2f}')

"""##line Plot"""

# Assuming y_test contains the actual values and y_pred contains the predicted values
plt.figure(figsize=(12, 6))
plt.plot(y_test, label='Actual', marker='o')
plt.plot(y_pred, label='Predicted', marker='x')
plt.legend()
plt.title('Actual vs. Predicted Values')
plt.xlabel('Data Point')
plt.ylabel('Value')
plt.grid(True)
plt.show()

"""## Scatter Plot"""

# Assuming y_test contains the actual values and y_pred contains the predicted values
plt.figure(figsize=(8, 8))
plt.scatter(y_test, y_pred, s=30, c='blue', alpha=0.5)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'k--', lw=2)
plt.title('Scatter Plot of Actual vs. Predicted Values')
plt.xlabel('Actual Values')
plt.ylabel('Predicted Values')
plt.grid(True)
plt.show()

"""#RNN"""

# Necessary Libraries are already imported above

#Loading our dataset.
data=df
data.head

# Load your temperature dataset
temperature_data = data['T2M_MIN'].values

# Data preprocessing
scaler = MinMaxScaler(feature_range=(0, 1))
temperature_data = scaler.fit_transform(temperature_data.reshape(-1, 1))

# Define the sequence length and split the data into sequences
sequence_length = 10  # You can adjust this to your specific needs
sequences = []
next_values = []

for i in range(len(temperature_data) - sequence_length):
    sequences.append(temperature_data[i:i+sequence_length])
    next_values.append(temperature_data[i+sequence_length])

X = np.array(sequences)
y = np.array(next_values)

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

# Build an RNN model
model = keras.Sequential()
model.add(keras.layers.SimpleRNN(50, activation='relu', input_shape=(sequence_length, 1)))
model.add(keras.layers.Dense(1))
model.compile(optimizer='adam', loss='mean_squared_error')

# Train the model
model.fit(X_train, y_train, epochs=15, batch_size=32)

# Make predictions
y_pred = model.predict(X_test)

# Inverse transform the predictions and actual values
y_pred = scaler.inverse_transform(y_pred)
y_test = scaler.inverse_transform(y_test)


# Plot the actual vs. predicted values
plt.figure(figsize=(12, 6))
plt.plot(y_test, label='Actual')
plt.plot(y_pred, label='Predicted')
plt.legend()
plt.show()

"""## RMSE , MAPE , MAE , MSE , R-Square"""

# Calculate the root mean squared error (RMSE)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))
print(f'Root Mean Squared Error: {rmse}')

# Printing RMSE's value again
#print(f'Root Mean Squared Error: {rmse}')

# Calculate Mean Absolute Percentage Error (MAPE)
def calculate_mape(actual, predicted):
    actual, predicted = np.array(actual), np.array(predicted)
    return np.mean(np.abs((actual - predicted) / actual)) * 100

# Assuming y_test contains the actual values and y_pred contains the predicted values
mape = calculate_mape(y_test, y_pred)
print(f'Mean Absolute Percentage Error (MAPE): {mape:.2f}%')

# Calculating Mean Absolute Error (MAE))
from sklearn.metrics import mean_absolute_error

# Assuming y_test contains the actual values and y_pred contains the predicted values
mae = mean_absolute_error(y_test, y_pred)
print(f'Mean Absolute Error (MAE): {mae:.2f}')

# Calculate Mean Squared Error (MSE)
# Assuming y_test contains the actual values and y_pred contains the predicted values
mse = mean_squared_error(y_test, y_pred)
print(f'Mean Squared Error (MSE): {mse:.2f}')

# Calculate R-Square
from sklearn.metrics import r2_score

# Assuming y_test contains the actual values and y_pred contains the predicted values
r_squared = r2_score(y_test, y_pred)
print(f'R-squared (R²): {r_squared:.2f}')

"""## Line Plot"""

# Assuming y_test contains the actual values and y_pred contains the predicted values
plt.figure(figsize=(12, 6))
plt.plot(y_test, label='Actual', marker='o')
plt.plot(y_pred, label='Predicted', marker='x')
plt.legend()
plt.title('Actual vs. Predicted Values')
plt.xlabel('Data Point')
plt.ylabel('Value')
plt.grid(True)
plt.show()

"""## Scatter Plot"""

# Assuming y_test contains the actual values and y_pred contains the predicted values
plt.figure(figsize=(8, 8))
plt.scatter(y_test, y_pred, s=30, c='blue', alpha=0.5)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'k--', lw=2)
plt.title('Scatter Plot of Actual vs. Predicted Values')
plt.xlabel('Actual Values')
plt.ylabel('Predicted Values')
plt.grid(True)
plt.show()

"""#CNN"""

#Necessary Libraries are imported above

#Loading our dataset.
data=df
data.head

# Load your temperature dataset
temperature_data = data['T2M_MIN'].values

# Data preprocessing
scaler = MinMaxScaler(feature_range=(0, 1))
temperature_data = scaler.fit_transform(temperature_data.reshape(-1, 1))

# Define the sequence length and split the data into sequences
sequence_length = 10  # You can adjust this to your specific needs
sequences = []
next_values = []

for i in range(len(temperature_data) - sequence_length):
    sequences.append(temperature_data[i:i+sequence_length])
    next_values.append(temperature_data[i+sequence_length])

X = np.array(sequences)
y = np.array(next_values)

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

# Reshape the data to be compatible with a 1D CNN model
X_train = X_train.reshape(-1, sequence_length, 1)
X_test = X_test.reshape(-1, sequence_length, 1)

# Build a 1D CNN model
model = keras.Sequential()
model.add(keras.layers.Conv1D(64, kernel_size=3, activation='relu', input_shape=(sequence_length, 1)))
model.add(keras.layers.Flatten())
model.add(keras.layers.Dense(1))
model.compile(optimizer='adam', loss='mean_squared_error')

# Train the model
model.fit(X_train, y_train, epochs=15, batch_size=32)

# Make predictions
y_pred = model.predict(X_test)

# Inverse transform the predictions and actual values
y_pred = scaler.inverse_transform(y_pred)
y_test = scaler.inverse_transform(y_test)


# Plot the actual vs. predicted values
plt.figure(figsize=(12, 6))
plt.plot(y_test, label='Actual')
plt.plot(y_pred, label='Predicted')
plt.legend()
plt.show()

"""## RMSE , MAPE , MAE , MSE , R-Square"""

# Calculate the root mean squared error (RMSE)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))
print(f'Root Mean Squared Error: {rmse}')

# Printing RMSE's value
#print(f'Root Mean Squared Error: {rmse}')

# Calculate Mean Absolute Percentage Error (MAPE)
def calculate_mape(actual, predicted):
    actual, predicted = np.array(actual), np.array(predicted)
    return np.mean(np.abs((actual - predicted) / actual)) * 100

# Assuming y_test contains the actual values and y_pred contains the predicted values
mape = calculate_mape(y_test, y_pred)
print(f'Mean Absolute Percentage Error (MAPE): {mape:.2f}%')

# Calculating Mean Absolute Error (MAE))
from sklearn.metrics import mean_absolute_error

# Assuming y_test contains the actual values and y_pred contains the predicted values
mae = mean_absolute_error(y_test, y_pred)
print(f'Mean Absolute Error (MAE): {mae:.2f}')

# Calculate Mean Squared Error (MSE)
# Assuming y_test contains the actual values and y_pred contains the predicted values
mse = mean_squared_error(y_test, y_pred)
print(f'Mean Squared Error (MSE): {mse:.2f}')

# Calculate R-Square
from sklearn.metrics import r2_score

# Assuming y_test contains the actual values and y_pred contains the predicted values
r_squared = r2_score(y_test, y_pred)
print(f'R-squared (R²): {r_squared:.2f}')

"""## line plot"""

# Assuming y_test contains the actual values and y_pred contains the predicted values
plt.figure(figsize=(12, 6))
plt.plot(y_test, label='Actual', marker='o')
plt.plot(y_pred, label='Predicted', marker='x')
plt.legend()
plt.title('Actual vs. Predicted Values')
plt.xlabel('Data Point')
plt.ylabel('Value')
plt.grid(True)
plt.show()

"""## Scatter plot"""

# Assuming y_test contains the actual values and y_pred contains the predicted values
plt.figure(figsize=(8, 8))
plt.scatter(y_test, y_pred, s=30, c='blue', alpha=0.5)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'k--', lw=2)
plt.title('Scatter Plot of Actual vs. Predicted Values')
plt.xlabel('Actual Values')
plt.ylabel('Predicted Values')
plt.grid(True)
plt.show()